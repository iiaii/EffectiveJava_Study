# #EffectiveJava/2장_객체생성과파괴/7다쓴객체참조를해제하라
## 6. 다쓴 객체 참조를 해제하라

가비지 컬렉터 때문에 메모리 관리에 더 이상 신경쓰지 않아도 된다고 오해할 수 있는데, 사실이 아님

- 메모리 누수 예제
```java
public class Stack {
	private Object[] elements;
	private int size = 0;
	private static final int DEFAULT_INITIAL_CAPACITY = 16;

	public Stack() {
		ensureCapacity();
		elements[size++] = e;
	}

	public Object pop() {
		if(size == 0)
			throw new EmptyStackException();
		return elements[--size];
	}

	// 원소를 위한 공간을 적어도 하나 이상 확보한다
	// 배열 크기를 늘려야 할때마다 2배씩 늘린다
	private void ensureCapacity() {
		if(elements.length == size)
			elements = Arrays.copyOf(elements, 2*size+1);
	}
}
```

이 스택을 오래 실행하다 보면 가비지 컬렉션 활동과 메모리 사용량이 늘어나 결국 성능이 저하된다. 심하면 디스크 페이징이나 OutOfMemoryError를 일으켜 프로그램이 종료될 수 있다.

이 코드의 메모리 누수는 스택이 커졌다가 줄어들었을 대 스택에서 꺼내진 객체들을 가비지 컬렉터가 회수하지 않는다. (프로그램에서 그 객체들을 더 이상 사용하지 않더라도 회수 안함)
-> 이 스택이 그 객체들의 다 쓴 참조를 여전히 가지고 있기 때문이다 (다시 쓰지 않을 참조를 뜻함)

가비지 컬렉션 언어에서는 (의도치 않게 객체를 살려두는) 메모리 누수를 찾기가 까다롭다. 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체뿐 아니라 그 객체가 참조하는 모든 객체(그리고 또 그 객체들이 참조하는 모든 객체…)를 회수해가지 못한다. 그래서 단 몇개의 객체가 매우 많은 객체를 회수되지 못하게 할 수 있고 잠재적으로 성능에 악영향을 줄 수 있다.

해법은 간단하다. 해당 참조를 다 썼을때 null처리(참조 해제)하면 된다.
예시의 스택 클래스에서는 각 원소의 참조가 더 이상 필요 없어지는 시점은 스택에서 꺼내질 때마다.
```java
public Object pop() {
	if(size == 0)
		throw new EmptyStackException();
	Object result = elements[--size];
	elements[size] = null; // 다쓴 참조 해제
	return result;
}
``` 

다 쓴 참조를 null처리하면 실수로 사용할때 NullPointerException을 던지며 종료된다.

그렇다고해서 매번 null처리하는 것은 프로그램을 필요이상으로 지저분하게 만든다.
**객체 참조를 null처리하는 일은 예외적인 경우여야 한다.** 다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효범위(scope)로 밀어내는 것임.(아이템57)

null 처리는 언제?
Stack 클래스는 자기 메모리를 직접 관리하기 때문에 메모리 누수에 취약하다. 이 스택은 (객체 자체가 아니라 객체 참조를 담는) elements 배열로 저장소 풀을 만들어 원소들을 관리하는데, 배열의 활성 영역에 속한 원소들이 사용되고 비활성 영역은 쓰이지 않는다. (가비지 컬렉터는 이 사실을 알 길이 없음. 가비지 컬렉터가 보기에는 비활성 영역에서 참조하는 객체도 똑같이 유효한 객체임) 

일반적으로 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다. 원소를 다 사용한 즉시 그 원소가 참조한 객체들을 다 null 처리해줘야 한다.

캐시 역시 메모리 누수를 일으키는 주범이다. 객체 참조를 캐시에 넣고 나서, 이 사실을 까맣게 잊은 채 그 객체를 다 쓴뒤로도 한참을 그냥 놔두는 일을 자주 접할 수 있다. 

운좋게 캐시 외부에서 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면 WeakHashMap을 사용해 캐시를 만든다. (다 쓴 엔트리는 그 즉시 자동으로 제거됨)
보통 캐시 엔트리의 유효기간을 정확히 정의하기 어렵기 때문에 시간이 지날 수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용한다.

이런 방식에서는 쓰지 않는 엔트리를 이따금 청소해줘야 한다. 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 대 부수 작업으로 수행하는 방법이 있다. LinkedHashMap은 removeEldestEntry 메서드를 써서 후자의 방식으로 처리한다. 

메모리 누수의 세번째 주범은 리스너 혹은 콜백이다. 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다. 뭔가 조치해주지 않으면 콜백은 쌓여간다. 이럴때 콜백을 약한 참조로 저장하면 가비지 컬렉터가 즉시 수거해 간다. (WeakHashMap)


::핵심 정리::

> 메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다. 이런 누수는 철저한 코드리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 한다. 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요하다.







